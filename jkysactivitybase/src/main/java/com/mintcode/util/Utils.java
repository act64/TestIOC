package com.mintcode.util;import android.content.Context;import android.content.res.Resources;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Matrix;import android.media.ExifInterface;import android.net.ConnectivityManager;import android.net.NetworkInfo;import android.os.Environment;import android.os.StatFs;import android.telephony.TelephonyManager;import android.text.Spannable;import android.text.SpannableString;import android.text.TextUtils;import android.text.style.AbsoluteSizeSpan;import android.text.style.ForegroundColorSpan;import android.util.DisplayMetrics;import android.util.Log;import android.util.Xml;import android.view.WindowManager;import com.jkys.jkysim.database.KeyValueDBService;import com.mintcode.App;import org.xmlpull.v1.XmlPullParser;import org.xmlpull.v1.XmlPullParserException;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.StringReader;import java.lang.reflect.Method;import java.text.ParseException;import java.text.ParsePosition;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.Formatter;import java.util.HashSet;import java.util.LinkedList;import java.util.List;import java.util.Locale;import java.util.Set;import java.util.regex.Matcher;import java.util.regex.Pattern;import cn.dreamplus.wentang.R;public class Utils {    private static final SimpleDateFormat dateFormat = new SimpleDateFormat(            "yyyy-MM-dd HH:mm", Locale.CHINA);    private static final SimpleDateFormat HHMMFormat = new SimpleDateFormat(            "HH:mm", Locale.CHINA);    private static final SimpleDateFormat DateFormat = new SimpleDateFormat(            "yyyy-MM-dd", Locale.CHINA);    private static final SimpleDateFormat TIMEFORMAT = new SimpleDateFormat(            "yyyy-MM-dd HH:mm:ss", Locale.CHINA);    public static final String YEAR_MONTH_DAY = "%s-%s-%s";    public static int getScreenWidth(Context context) {        WindowManager mWm = (WindowManager) context.getApplicationContext()                .getSystemService(Context.WINDOW_SERVICE);        DisplayMetrics dMetrics = new DisplayMetrics();        mWm.getDefaultDisplay().getMetrics(dMetrics);        return dMetrics.widthPixels;    }    public static int getScreenHeight(Context context) {        WindowManager mWm = (WindowManager) context.getApplicationContext()                .getSystemService(Context.WINDOW_SERVICE);        DisplayMetrics dMetrics = new DisplayMetrics();        mWm.getDefaultDisplay().getMetrics(dMetrics);        return dMetrics.heightPixels;    }    public static boolean isCellphone(String str) {        Pattern pattern = Pattern.compile("1[0-9]{10}");        Matcher matcher = pattern.matcher(str);        if (matcher.matches()) {            return true;        } else {            return false;        }    }    public static float getScreenDensity(Context context) {        try {            DisplayMetrics dm = new DisplayMetrics();            WindowManager manager = (WindowManager) context.getApplicationContext()                    .getSystemService(Context.WINDOW_SERVICE);            manager.getDefaultDisplay().getMetrics(dm);            return dm.density;        } catch (Exception ex) {        }        return 1.0f;    }    public static int convertDIP2PX(Context context, int dip) {        float scale = context.getResources().getDisplayMetrics().density;        return (int) (dip * scale + 0.5f * (dip >= 0 ? 1 : -1));    }    public static int convertPX2DIP(Context context, int px) {        float scale = context.getResources().getDisplayMetrics().density;        return (int) (px / scale + 0.5f * (px >= 0 ? 1 : -1));    }    public static float sp2px(Context context, float spValue) {        float scale = context.getResources().getDisplayMetrics().scaledDensity;        return (spValue * scale + 0.5f);    }    /**     * ���� yyyy-mm-dd     *     * @param date     * @return     */    public static String getDateFormat(Date date) {        return DateFormat.format(date);    }    public static Date formateDateString(String dateString) {        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-M-d");        Date date = null;        try {            date = sdf.parse(dateString);        } catch (ParseException e) {            e.printStackTrace();        }        return date;    }    public static SpannableString getWarning(Resources res, String text,                                             String warningInfo, float warningInfoSp) {        if (!TextUtils.isEmpty(warningInfo)) {            SpannableString spannableStr = new SpannableString(text                    + warningInfo);            spannableStr.setSpan(                    new ForegroundColorSpan(res.getColor(R.color.text_red)),                    text.length(), (text + warningInfo).length(),                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);            spannableStr.setSpan(                    new AbsoluteSizeSpan(sp2px(res, warningInfoSp)),                    text.length(), (text + warningInfo).length(),                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);            return spannableStr;        }        return null;    }    public static int sp2px(Resources res, float spValue) {        float scale = res.getDisplayMetrics().density;        return (int) (spValue * scale + 0.5f);    }    /**     * ���ؼ��������     */    public static long getIntervalTime(String lastDateString,                                       String currentDateString) {        ParsePosition parse = new ParsePosition(0);        Date lastDate = dateFormat.parse(lastDateString, parse);        parse = new ParsePosition(0);        Date currentDate = dateFormat.parse(currentDateString, parse);        long intervalSecond = Math.abs(currentDate.getTime()                - lastDate.getTime()) / 1000;        return intervalSecond / 60;    }    public static String msgTime(long time) {        return dateFormat.format(time);    }    /**     * ��ʽ��ʱ��     *     * @param count ����     * @return ����ʱ���ַ�     */    public static String formatTimeByS(int count) {        int second = count % 60;        int minute = count / 60;        int hour = minute / 60;        minute = minute % 60;        if (count < 60) {            return new Formatter().format("%d��", second).toString();        } else if (count >= 60 && count < 3600) {            return new Formatter().format("%d��%d��", minute, second).toString();        } else {            return new Formatter().format("%dʱ%d��%d��", hour, minute, second)                    .toString();        }    }    public static String currentTime() {        return dateFormat.format(new Date());    }    public static String currentDate() {        return DateFormat.format(new Date());    }    public static Bitmap decodeFile(String path) {// you can provide file path        // here        int orientation;        try {            if (path == null) {                return null;            }            // decode image size            BitmapFactory.Options o = new BitmapFactory.Options();            o.inJustDecodeBounds = true;            FileInputStream stream1 = new FileInputStream(path);            BitmapFactory.decodeStream(stream1, null, o);            stream1.close();            // Find the correct scale value. It should be the power of 2.            final int REQUIRED_SIZE = 300;            int width_tmp = o.outWidth, height_tmp = o.outHeight;            int scale = 1;            while (true) {                if (width_tmp / 2 < REQUIRED_SIZE                        || height_tmp / 2 < REQUIRED_SIZE)                    break;                width_tmp /= 2;                height_tmp /= 2;                scale *= 2;            }            // decode with inSampleSize            BitmapFactory.Options o2 = new BitmapFactory.Options();            o2.inSampleSize = scale;            Bitmap bm = BitmapFactory.decodeFile(path, o2);            Bitmap bitmap = bm;            ExifInterface exif = new ExifInterface(path);            orientation = exif                    .getAttributeInt(ExifInterface.TAG_ORIENTATION, 1);            Log.e("ExifInteface .........", "rotation =" + orientation);            // exif.setAttribute(ExifInterface.ORIENTATION_ROTATE_90, 90);            Log.e("orientation", "" + orientation);            Matrix m = new Matrix();            if ((orientation == ExifInterface.ORIENTATION_ROTATE_180)) {                m.postRotate(180);                // m.postScale((float) bm.getWidth(), (float) bm.getHeight());                // if(m.preRotate(90)){                Log.e("in orientation", "" + orientation);                bitmap = Bitmap.createBitmap(bm, 0, 0, bm.getWidth(),                        bm.getHeight(), m, true);                return bitmap;            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_90) {                m.postRotate(90);                Log.e("in orientation", "" + orientation);                bitmap = Bitmap.createBitmap(bm, 0, 0, bm.getWidth(),                        bm.getHeight(), m, true);                return bitmap;            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_270) {                m.postRotate(270);                Log.e("in orientation", "" + orientation);                bitmap = Bitmap.createBitmap(bm, 0, 0, bm.getWidth(),                        bm.getHeight(), m, true);                return bitmap;            }            return bitmap;        } catch (Exception e) {            return null;        }    }    public static  <T> List<T> removeAll_Fast(List<T> source, List<T> destination) {        List<T> result = new LinkedList<T>();        Set<T> destinationSet = new HashSet<T>(destination);        for(T t : source) {            if (!destinationSet.contains(t)) {                result.add(t);            }        }        return result;    }    /*     * ������������ת��Ϊ���ڸ�ʽ���ַ�     *     * @param time     * @param format     * @return     */    public static String convert2String(long time, String format) {        SimpleDateFormat sf = new SimpleDateFormat(format);        Date date = new Date(time);        return sf.format(date);    }    /**     * string����ת��Ϊlong���� strTimeҪת����String���͵�ʱ�� formatTypeʱ���ʽ     * strTime��ʱ���ʽ��formatType��ʱ���ʽ������ͬ     *     * @param strTime     * @param formatType     * @return     * @throws ParseException     */    public static long dateToLong(String strTime, String formatType) {        try {            Date date = stringToDate(strTime, formatType);            return date.getTime();        } catch (ParseException e) {            return 0;        }    }    /**     * ��ȡʱ�� Сʱ+����     *     * @param date     * @return     */    public static long getDateHM(Date date) {        String strDate = HHMMFormat.format(date);        String[] arr = strDate.split(":");        long hour = Integer.parseInt(arr[0]) * 60 * 60 * 1000;        long min = Integer.parseInt(arr[1]) * 60 * 1000;        return hour + min;    }    /**     * ��ȡ�м��ʱ��     *     * @param start     * @param end     * @return     */    public static long getMiddleTime(long start, long end) {        return (end - start) / 2 + start;    }    /**     * ������������ת��Ϊ���ڸ�ʽ���ַ�     *     * @param time     * @return yyyy-MM-dd     */    public static String convert2String(long time) {        Date date = new Date(time);        return DateFormat.format(date);    }    // string����ת��Ϊdate����    // strTimeҪת����string���͵�ʱ�䣬formatTypeҪת���ĸ�ʽyyyy-MM-dd HH:mm:ss//yyyy��MM��dd��    // HHʱmm��ss�룬    // strTime��ʱ���ʽ����Ҫ��formatType��ʱ���ʽ��ͬ    public static Date stringToDate(String strTime, String formatType)            throws ParseException {        SimpleDateFormat formatter = new SimpleDateFormat(formatType);        Date date = null;        date = formatter.parse(strTime);        return date;    }    public static Date stringToDate(String longStr) {        Date date = new Date(Long.valueOf(longStr));        return date;    }    public static String yearMonthDay(int year, int month, int day) {        month = month + 1;        String mStr = month + "";        if (month < 10) {            mStr = "0" + month;        }        String dStr = day + "";        if (day < 10) {            dStr = "0" + day;        }        return String.format(YEAR_MONTH_DAY, year, mStr, dStr);    }    public static String hourMinutes(int hour, int minute) {        String mStr = hour + "";        if (hour < 10) {            mStr = "0" + hour;        }        String dStr = minute + "";        if (minute < 10) {            dStr = "0" + minute;        }        return mStr + ":" + dStr;    }    public static String getDateHMStr(Long times) {        if (times == null)            return "00:00";        long onehour = 60 * 60 * 1000;        long hour = times / onehour;        String hour_str = "";        if (hour < 10)            hour_str = "0" + hour;        else            hour_str = "" + hour;        String min_str = "";        long min = (times - (hour * onehour)) / (60 * 1000);        if (min < 10)            min_str = "0" + min;        else            min_str = "" + min;        return hour_str + ":" + min_str;    }    public static int getAge(Date birthDay) throws Exception {        Calendar cal = Calendar.getInstance();        if (cal.before(birthDay)) {            throw new IllegalArgumentException("����ʱ����ڵ�ǰʱ��!");        }        int yearNow = cal.get(Calendar.YEAR);        int monthNow = cal.get(Calendar.MONTH) + 1;// ע��˴�������1�Ļ��������Ǵ����        int dayOfMonthNow = cal.get(Calendar.DAY_OF_MONTH);        cal.setTime(birthDay);        int yearBirth = cal.get(Calendar.YEAR);        int monthBirth = cal.get(Calendar.MONTH);        int dayOfMonthBirth = cal.get(Calendar.DAY_OF_MONTH);        int age = yearNow - yearBirth;        if (monthNow <= monthBirth) {            if (monthNow == monthBirth) {                // monthNow==monthBirth                if (dayOfMonthNow < dayOfMonthBirth) {                    age--;                } else {                    // do nothing                }            } else {                // monthNow>monthBirth                age--;            }        } else {            // monthNow<monthBirth            // donothing        }        return age;    }    /**     * ��ȡ���30���ʱ���     *     * @return     */    public static String[] get30days() {        String[] times = new String[2];        Calendar cal = Calendar.getInstance();        cal.add(Calendar.DAY_OF_YEAR, -30);        cal.set(Calendar.HOUR_OF_DAY, 0);        cal.set(Calendar.MINUTE, 0);        cal.set(Calendar.SECOND, 0);        // times[0] = String.valueOf(cal.getTimeInMillis());        times[0] = TIMEFORMAT.format(cal.getTime());        cal = Calendar.getInstance();        cal.set(Calendar.HOUR_OF_DAY, 23);        cal.set(Calendar.MINUTE, 59);        cal.set(Calendar.SECOND, 59);        // times[1] = String.valueOf(cal.getTimeInMillis());        times[1] = TIMEFORMAT.format(cal.getTime());        return times;    }    public static boolean isEmpty(String value) {        if (TextUtils.isEmpty(value) || "null".equals(value)) {            return true;        }        return false;    }    public static byte[] readStream(InputStream inStream) throws Exception {        ByteArrayOutputStream outStream = new ByteArrayOutputStream();        byte[] buffer = new byte[1024];        int len = -1;        while ((len = inStream.read(buffer)) != -1) {            outStream.write(buffer, 0, len);        }        outStream.close();        inStream.close();        return outStream.toByteArray();    }    public static XmlPullParser getXmlPullParserFromString(String xmlString)            throws XmlPullParserException {        XmlPullParser xmlpullparser = Xml.newPullParser();        xmlpullparser.setInput(new StringReader(xmlString));        return xmlpullparser;    }    public static String getXmlString(XmlPullParser xmlPullParser)            throws XmlPullParserException, IOException {        String value = xmlPullParser.nextText();        return value;    }    public static String timeFormat(String time) {        return TIMEFORMAT.format(new Date(Long.parseLong(time)));    }    /**     * @param methodObject �������ڵĶ���     * @param methodName   ������     * @param args         �������������     */    public static Object invokeMethod(Object methodObject, String methodName,                                      Object[] args) throws Exception {        Class ownerClass = methodObject.getClass();        Method method;        if (args != null) {            Class[] argsClass = new Class[args.length];            for (int i = 0, j = args.length; i < j; i++) {                argsClass[i] = args[i].getClass();            }            method = ownerClass.getMethod(methodName, argsClass);            return method.invoke(methodObject, args);        } else {            method = ownerClass.getMethod(methodName);            return method.invoke(methodObject);        }    }    public static int getArrayPosition(String[] array, String value) {        if (!TextUtils.isEmpty(value)) {            for (int i = 0; i < array.length; i++) {                if (value.equals(array[i])) {                    return i;                }            }        }        return 0;    }    public static boolean haveInternet(Context context) {        Context dcontext = context.getApplicationContext();        ConnectivityManager connectivity = (ConnectivityManager) dcontext.getApplicationContext()                .getSystemService(Context.CONNECTIVITY_SERVICE);        if (connectivity == null) {        } else {            NetworkInfo[] info = connectivity.getAllNetworkInfo();            if (info != null) {                for (int i = 0; i < info.length; i++) {                    if (info[i].getState() == NetworkInfo.State.CONNECTED) {                        return true;                    }                }            }        }        return false;    }    /**     * 获取到网络状态详情wifi、2G、3G、4G     * @return     */    public static String getNetState() {        Context dcontext = App.context;        ConnectivityManager connectivityManager = (ConnectivityManager) dcontext                .getSystemService(Context.CONNECTIVITY_SERVICE);        // 网络开关都没有打开 返回没有打开        if (connectivityManager == null) {            return "NetWorkUnavailable-NoPermission";        } else {            NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();            // 打开了网络，但是不可用。            if (networkInfo == null || !networkInfo.isAvailable()){                return "NetWorkUnavailable-DisConnected-All";            }else{ // 可能联网                int networkInfoType = networkInfo.getType();                if (networkInfoType == ConnectivityManager.TYPE_MOBILE) {                    TelephonyManager telephonyManager = (TelephonyManager) dcontext.getApplicationContext().getSystemService(Context.TELEPHONY_SERVICE);                    int networkType = telephonyManager.getNetworkType();                    return getNetworkClassByType(networkType);                } else if (networkInfoType == ConnectivityManager.TYPE_WIFI) {                    return "wifi";                }else{                    return "UnknowNetWork";                }            }//            NetworkInfo[] info = connectivityManager.getAllNetworkInfo();//            if (info != null) {//                for (int i = 0; i < info.length; i++) {//                    if (info[i].getState() == NetworkInfo.State.CONNECTED) {//                        // 判断是否是手机网路在做2G、3G、4G网络的判断//                        if (info[i].getType() == ConnectivityManager.TYPE_MOBILE) {//                            TelephonyManager telephonyManager = (TelephonyManager) dcontext.getSystemService(Context.TELEPHONY_SERVICE);//                            int networkType = telephonyManager.getNetworkType();//                            return getNetworkClassByType(networkType);//                        } else if (info[i].getType() == ConnectivityManager.TYPE_WIFI) {//                            return "wifi";//                        }//                    }else{//                        return "NetWorkUnavailable-DisConnected-All";//                    }//                }//            }        }//        return "none";    }    /**     * 获取网络状态字符串     * @return     */    public static String getInternetState(){        Context dcontext= App.context;        ConnectivityManager connectivity = (ConnectivityManager) dcontext.getApplicationContext()                .getSystemService(Context.CONNECTIVITY_SERVICE);        if (connectivity == null) {        } else {            NetworkInfo[] info = connectivity.getAllNetworkInfo();            if (info != null) {                for (int i = 0; i < info.length; i++) {                    if (info[i].getState() == NetworkInfo.State.CONNECTED) {                        if (info[i].getType()== ConnectivityManager.TYPE_MOBILE)                            return "cellnet";                        else if (info[i].getType()== ConnectivityManager.TYPE_WIFI){                            return "wifi";                        }                    }                }            }        }        return "none";    }    // 根据networkType来判断当前网络是2G、3G、4G    private static String getNetworkClassByType(int networkType) {        switch (networkType) {            case NETWORK_TYPE_UNAVAILABLE:                return "NetWorkUnavailable-DisConnected-Phone";            case NETWORK_TYPE_GPRS:            case NETWORK_TYPE_EDGE:            case NETWORK_TYPE_CDMA:            case NETWORK_TYPE_1xRTT:            case NETWORK_TYPE_IDEN:                return "2G";            case NETWORK_TYPE_UMTS:            case NETWORK_TYPE_EVDO_0:            case NETWORK_TYPE_EVDO_A:            case NETWORK_TYPE_HSDPA:            case NETWORK_TYPE_HSUPA:            case NETWORK_TYPE_HSPA:            case NETWORK_TYPE_EVDO_B:            case NETWORK_TYPE_EHRPD:            case NETWORK_TYPE_HSPAP:                return "3G";            case NETWORK_TYPE_LTE:                return "4G";            default:                return "UnknowNetWork";        }    }    public static String getJidToUsername(String jid) {        return jid.split("@")[0];    }    public static String bytesToHexString(byte[] src) {        StringBuilder stringBuilder = new StringBuilder("");        if (src == null || src.length <= 0) {            return null;        }        for (int i = 0; i < src.length; i++) {            int v = src[i] & 0xFF;            String hv = Integer.toHexString(v);            if (hv.length() < 2) {                stringBuilder.append(0);            }            stringBuilder.append(hv);        }        return stringBuilder.toString().toUpperCase();    }    public static String hexString2binaryString(String hexString) {        if (hexString == null || hexString.length() % 2 != 0)            return null;        String bString = "", tmp;        for (int i = 0; i < hexString.length(); i++) {            tmp = "0000"                    + Integer.toBinaryString(Integer.parseInt(                    hexString.substring(i, i + 1), 16));            bString += tmp.substring(tmp.length() - 4);        }        return bString;    }    public static boolean toastIsNetworkConnected(Context context) {        if (isNetworkConnected(context)) {            return true;        }        return false;    }    public static boolean isNetworkConnected(Context context) {        if (context != null) {            ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getApplicationContext()                    .getSystemService(Context.CONNECTIVITY_SERVICE);            NetworkInfo mNetworkInfo = mConnectivityManager                    .getActiveNetworkInfo();            if (mNetworkInfo != null) {                return mNetworkInfo.isAvailable();            }        }        return false;    }    /**     * 计算Sdcard的剩余大小     *     * @return MB     */    public static long getAvailableSize() {        //得到外部储存sdcard的状态        String sdcard = Environment.getExternalStorageState();        //外部储存sdcard存在的情况        String state = Environment.MEDIA_MOUNTED;        //获得路径        File file = Environment.getExternalStorageDirectory();        StatFs statFs = new StatFs(file.getPath());        if (sdcard.equals(state)) {            //获得Sdcard上每个block的size            long blockSize = statFs.getBlockSize();            //获取可供程序使用的Block数量            long blockavailable = statFs.getAvailableBlocks();            //计算标准大小使用：1024，当然使用1000也可以            long blockavailableTotal = blockSize * blockavailable / 1000 / 1000;            return blockavailableTotal;        } else {            return -1;        }    }    /**     * 获取当前系统时间     *     * @param     * @return void     * @TODO TODO     */    public static long getCurrentTime() {        Date date = null;        long beginTime = 0;        SimpleDateFormat sDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        try {            date = sDate.parse(sDate.format(new Date()));        } catch (java.text.ParseException e) {            e.printStackTrace();        }        if (null != date) {            beginTime = date.getTime();        }        return beginTime;    }    /**     * 验证是否是游客     *     * @return true 是游客 false 不是游客     */    public static boolean checkUidForVisitor() {        String uid = KeyValueDBService.getInstance().find(Keys.UID);        if (TextUtils.isEmpty(uid) || "-1000".equals(uid)) {            return true;        }        return false;    }    /**     * 正则匹配用户密码（6-20位数字或字母）     *     * @param password     * @return true 匹配正确，false 匹配错误     */    public static boolean isPassword(String password) {        if (TextUtils.isEmpty(password)) {            return false;        }        Pattern p = Pattern.compile("^[0-9A-Za-z]{6,20}$");        Matcher m = p.matcher(password);        return m.matches();    }    // 适配低版本手机 这些事Android原生常量，一般不是专业的人是看不懂的，嘿嘿^-^,反正我是看不懂。    /** Network type is unknown */    public static final int NETWORK_TYPE_UNKNOWN = 0;    /** Current network is GPRS */    public static final int NETWORK_TYPE_GPRS = 1;    /** Current network is EDGE */    public static final int NETWORK_TYPE_EDGE = 2;    /** Current network is UMTS */    public static final int NETWORK_TYPE_UMTS = 3;    /** Current network is CDMA: Either IS95A or IS95B */    public static final int NETWORK_TYPE_CDMA = 4;    /** Current network is EVDO revision 0 */    public static final int NETWORK_TYPE_EVDO_0 = 5;    /** Current network is EVDO revision A */    public static final int NETWORK_TYPE_EVDO_A = 6;    /** Current network is 1xRTT */    public static final int NETWORK_TYPE_1xRTT = 7;    /** Current network is HSDPA */    public static final int NETWORK_TYPE_HSDPA = 8;    /** Current network is HSUPA */    public static final int NETWORK_TYPE_HSUPA = 9;    /** Current network is HSPA */    public static final int NETWORK_TYPE_HSPA = 10;    /** Current network is iDen */    public static final int NETWORK_TYPE_IDEN = 11;    /** Current network is EVDO revision B */    public static final int NETWORK_TYPE_EVDO_B = 12;    /** Current network is LTE */    public static final int NETWORK_TYPE_LTE = 13;    /** Current network is eHRPD */    public static final int NETWORK_TYPE_EHRPD = 14;    /** Current network is HSPA+ */    public static final int NETWORK_TYPE_HSPAP = 15;    /** */    public static final int NETWORK_TYPE_UNAVAILABLE = -1;}